// LinkedList.cpp : 콘솔 응용 프로그램에 대한 진입점을 정의합니다.//#include "stdafx.h"#include "stdlib.h"typedef struct listNode{ int Data; struct listNode *next;//다음노드와 이전노드를 연결하는 포인터 struct listNode *prev;}Node;//이름을 지어줌Node *createNode(int data)//노드 생성{ Node *newNode = (Node*)malloc(sizeof(Node));//노드 만큼의 메모리 할당 newNode->Data = data; newNode->next = NULL; newNode->prev = NULL;//초기화 return newNode;//새로 만든애를 리턴}void deleteNode(Node *Node/*지워질노드*/){ free(Node);//메모리상에서 삭제}Node *getNodeAt(Node *head/*노드의 시작점*/,int index)//몇번째 인덱스에서 노드를 가져와라{ Node *horse = head;//머리부터 달려라 int count = 0; while(horse != NULL)//인덱스가 NULL이 아닐때까지 달려라 {  if(count++ == index)//카운트가 증가했을때 index와 같다면  {   return horse;  }  horse = horse->next;//카운트가 index와 다르다면 } return NULL;//아무것도 찾지 못했을때 리턴}int countNode(Node *head)//list안에 Node가 몇개있는지 count해주는 함수{ int count = 0;//몇개인지 세주는 변수 Node *horse = head; while(horse != NULL) {  horse = horse->next;  count++; } return count;}void addNode(Node **head, Node *newNode/*새로 추가될 노드*/){ //리스트가 존재하지 않을때 if((*head)==NULL)//head가 NULL일 때 {  *head = newNode; } else {  Node *horse = (*head);//맨 뒤까지 가기위해 필요함  while(horse->next != NULL)//horse의 next가 NULL이 아닐 때까지 달려라  {   horse = horse->next;  }  horse->next = newNode;//while문에서 끝을 찾은 후 Node생성  newNode->prev = horse;//끝Node생성 후 horse와 연결 } //리스트가 존재할때}void insertAfterNode(Node *current/*중간노드*/,Node *newNode)//리스트 중간에 노드삽입{ //head일때 if(current->prev == NULL && current->next == NULL) //중간노드 앞뒤가 NULL일 때 {  current->next = newNode;  newNode->prev = current;//원래있던 Node와 연결 } //head가 아닐때     //tail에 삽입 if(current->next == NULL) {  current->next = newNode;  newNode->prev = current; }     //Node중간에 삽입 else {  current->next->prev = newNode;//current와 newNode를 연결시켜줌  newNode->prev = current;//newNode와 current를 연결  newNode->next = current->next;//current다음에 있던 Node와 newNode연결  current->next = newNode;//current다음에 있던 Node와 newNode연결 }}void removeNode(Node **head/*head에 변화가 일어나야해서 더블포인터*/,Node *remove/*지울 노드*/){ //remove Node가 head일때 if(*head == remove) {  *head = remove->next;//head를 앞으로 한칸 밀어준다. } //remove Node의 다음링크에 Node가 있을때 if(remove->next != NULL)//remove의 다음이 NULL이 아닐때 {  remove->next->prev = remove->prev;//removeNode다음 Node의 뒤와 연결하는 포인터를 removeNode 뒤에 있는 Node와 연결 } //remove Node의 이전링크에 Node가 있을때 if(remove->prev != NULL) {  remove->prev->next = remove->next; } deleteNode(remove);//Node삭제}int _tmain(int argc, _TCHAR* argv[]){ int i = 0; int count = 0; Node *list = NULL; Node *newNode = NULL; Node *curr = NULL; for(i=0;i<5;i++)//노드생성 {  newNode = createNode(i);  addNode(&list,newNode); } count = countNode(list); for(i=0;i<count;i++)//생성된 노드 출력 {  curr=getNodeAt(list,i);  printf("list[%d] = %d\n",i,curr->Data); } printf("==============5개의 노드 생성==============\n"); newNode = createNode(99);//99라는 데이터를 가진 노드생성 curr = getNodeAt(list,0);//index=0을 가진 노드생성 insertAfterNode(curr,newNode);//0다음 index에 노드삽입 newNode = createNode(444);//444라는 데이터를 가진 노드생성 curr = getNodeAt(list,4);//index=4를 가진 노드생성 insertAfterNode(curr,newNode);//4다음 index에 노드삽입 count = countNode(list); for(i=0;i<count;i++) {  curr = getNodeAt(list,i);  printf("list[%d] = %d\n",i,curr->Data); } printf("=========1번,5번 다음노드에 99,444 삽입=========\n"); newNode = getNodeAt(list,1);//index=1에 있는 노드 removeNode(&list,newNode);//삭제 newNode = getNodeAt(list,0);//index=0에 있는 노드 removeNode(&list,newNode);//삭제 count = countNode(list); for(i=0;i<count;i++) {  curr = getNodeAt(list,i);  printf("list[%d] = %d\n",i,curr->Data); } printf("=========0번,1번 노드 삭제========="); system("pause"); return 0;}
