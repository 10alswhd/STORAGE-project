#include <stdio.h>#include <stdlib.h>#include <windows.h>#define M 9#define N 8#define STACK_SIZE M*Nint move[4][2] = { { -1, 0 }, { 0, 1 }, { 1, 0 }, { 0, -1 }};typedef struct { int i; int j; int dir;}element;element stack[STACK_SIZE];int top = -1;element current = { 1, 1 };void push(element *stack, element item) { if (top >= STACK_SIZE - 1) {  printf("Stack is full\n");  return; } stack[++top] = item;}element pop(element *stack) { if (top == -1) {  printf("Stack is empty\n");  exit(1); } else return stack[top--];}int isEmpty(element *stack) { if (top == -1) return 1; else return 0;}void printMaze(int m[M + 2][N + 2]);void mazePath();void printPath();void printCurrent(int m[M + 2][N + 2]);void main() { int end; mazePath(); fflush(stdin); printf("Press any key to exit\n"); scanf("%d", &end);}void printMaze(int m[M + 2][N + 2]) { int i, j; printf("\n\n"); for (i = 0; i<M + 2; i++) {  for (j = 0; j<N + 2; j++) {   if (m[i][j] == 0) printf("  ");   else if (m[i][j] == 2) printf("○");   else if (m[i][j] == 3) printf("☆");   else printf("▩");  }  printf("\n"); } printf("\n\n");}void mazePath() { int maze[M + 2][N + 2] = {  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },  { 1, 2, 1, 1, 0, 1, 0, 1, 1, 1 },  { 1, 0, 0, 1, 0, 0, 0, 1, 0, 1 },  { 1, 1, 0, 0, 0, 1, 0, 0, 0, 1 },  { 1, 1, 1, 0, 0, 0, 1, 0, 1, 1 },  { 1, 0, 0, 0, 1, 0, 1, 0, 1, 1 },  { 1, 1, 0, 1, 0, 0, 0, 1, 1, 1 },  { 1, 0, 0, 0, 1, 1, 1, 1, 1, 1 },  { 1, 0, 1, 0, 1, 1, 0, 0, 0, 1 },  { 1, 0, 1, 0, 0, 0, 0, 1, 3, 1 },  { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 } }; int mark[M + 2][N + 2] = { 0 }; int next_i, next_j; int i, j, dir; int start; element item = { 1, 1, 1 }; push(stack, item); printMaze(maze); printf("Press any key to start: "); scanf("%d", &start); while (!isEmpty(stack)) {  item = pop(stack);  i = item.i;  j = item.j;  dir = item.dir;  while (dir <= 3) {   next_i = i + move[dir][0];   next_j = j + move[dir][1];   if (next_i == M && next_j == N) {    printMaze(maze);    printf("\nThe path in stack is as follows.\n\n");    printPath();    printf("i = %d, j = %d\n", next_i, next_j);    printf("m = %d, n = %d\n", M, N);    printf("\nThe mark is as follows.\n");    printMaze(mark);    return;   }   if (maze[next_i][next_j] == 0 && mark[next_i][next_j] == 0) {    mark[next_i][next_j] = 1;    item.i = next_i;    item.j = next_j;    item.dir = dir;    push(stack, item);    i = next_i;    j = next_j;    dir = 0;   }   else dir++;   printCurrent(maze);   Sleep(300);   system("cls");  } } printf("There is no path\n");}void printPath() { int path[M + 2][N + 2] = { 0 }; int i, j; for (i = 17; i>top; i--) printf("|       |\n");  //i = M*N (최대) for (i = top; i >= 0; i--) {  path[stack[i].i][stack[i].j] = 1;  printf("|%d, %d, %d|\n", stack[i].i, stack[i].j, stack[i].dir); } printf("i, j, dir\n"); printf("----------------\n"); for (i = 0; i<M + 2; i++) {  for (j = 0; j<N + 2; j++) {   if (path[i][j] == 0) printf("  ");   else printf("●");  }  printf("\n"); } printf("\n\n");}void printCurrent(int m[M + 2][N + 2]) { int i, j; current.i = stack[top].i; current.j = stack[top].j; printf("\n\n"); for (i = 17; i>top; i--) printf("|       |\n");  //i = M*N (최대) for (i = top; i >= 0; i--) printf("|%d, %d, %d|\n", stack[i].i, stack[i].j, stack[i].dir); printf("i, j, dir\n"); printf("----------------\n"); for (i = 0; i<M + 2; i++) {  for (j = 0; j<N + 2; j++) {   if (i == current.i && j == current.j) printf("○");   else if (m[i][j] == 3) printf("☆");   else if (m[i][j] == 2) printf("  ");   else if (m[i][j] == 1) printf("▩");   else printf("  ");  }  printf("\n"); } printf("\n\n");}
